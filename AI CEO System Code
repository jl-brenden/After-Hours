local CEO2 = script.Parent
local RootPart = CEO2:FindFirstChild("RootPart")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local FOLLOW_RADIUS = 40      -- Distance to start following a player
local STOP_RADIUS = 0         -- Distance to stop moving toward a player
local WANDER_RADIUS = 20      -- How far CEO2 can wander from its current position
local MOVE_SPEED = 20          -- Studs per second (slow movement)
local WANDER_WAIT_MIN = 0     -- Minimum seconds to wait before next wander
local WANDER_WAIT_MAX = 1     -- Maximum seconds to wait before next wander

-- Get the Y level CEO2 should stay at (initial spawn Y)
local FIXED_Y = RootPart and RootPart.Position.Y or 0

-- Reference to the Safe Spot part
local SafeSpot = Workspace:FindFirstChild("Parts") and Workspace.Parts:FindFirstChild("Safe Spot")

-- Utility: Check if a player's HumanoidRootPart is on the Safe Spot
local function isOnSafeSpot(hrp)
	if not SafeSpot or not hrp then
		return false
	end
	-- Calculate the bounds of the Safe Spot part
	local partPos = SafeSpot.Position
	local partSize = SafeSpot.Size
	local min = partPos - (partSize / 2)
	local max = partPos + (partSize / 2)
	local pos = hrp.Position
	-- Check if the player's HumanoidRootPart is within the bounds (XZ only, allow some Y tolerance)
	local yTolerance = 3
	if pos.X >= min.X and pos.X <= max.X and
	   pos.Z >= min.Z and pos.Z <= max.Z and
	   pos.Y >= min.Y - yTolerance and pos.Y <= max.Y + yTolerance then
		return true
	end
	return false
end

-- Utility: Get CEO2's current position
local function getPosition()
	return RootPart and RootPart.Position or Vector3.new(0,0,0)
end

-- Utility: Find nearest player within radius, ignoring those on the Safe Spot
local function getNearestPlayer()
	local myPos = getPosition()
	local nearest = nil
	local nearestDist = FOLLOW_RADIUS
	for i, player in Players:GetPlayers() do
		local char = player.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			local hrp = char.HumanoidRootPart
			if not isOnSafeSpot(hrp) then
				local dist = (hrp.Position - myPos).Magnitude
				if dist < nearestDist then
					nearest = hrp
					nearestDist = dist
				end
			end
		end
	end
	return nearest, nearestDist
end

-- Utility: Move CEO2 toward a target position (horizontal only, fixed Y)
local function moveTo(targetPos)
	local startPos = getPosition()
	local currentPos = startPos
	local targetXZ = Vector3.new(targetPos.X, 0, targetPos.Z)
	local lastDist = (Vector3.new(currentPos.X, 0, currentPos.Z) - targetXZ).Magnitude
	while true do
		currentPos = getPosition()
		local currentXZ = Vector3.new(currentPos.X, 0, currentPos.Z)
		local dist = (currentXZ - targetXZ).Magnitude
		if dist < 0.2 or dist > lastDist then
			break
		end
		lastDist = dist
		local direction = (targetXZ - currentXZ).Unit
		local step = math.min(MOVE_SPEED * task.wait(), dist)
		local nextXZ = currentXZ + direction * step
		-- Use fixed Y
		local nextPos = Vector3.new(nextXZ.X, FIXED_Y, nextXZ.Z)
		-- Face toward movement direction
		local lookAt = nextPos + direction
		local newCFrame = CFrame.new(nextPos, lookAt)
		CEO2:PivotTo(newCFrame)
	end
end

-- Utility: Pick a random point nearby for wandering (fixed Y)
local function getRandomWanderPoint()
	local basePos = getPosition()
	local angle = math.random() * 2 * math.pi
	local radius = math.random() * WANDER_RADIUS
	local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
	local targetXZ = basePos + offset
	-- Use fixed Y
	return Vector3.new(targetXZ.X, FIXED_Y, targetXZ.Z)
end

-- Ensure RootPart is not anchored
if RootPart and RootPart.Anchored then
	RootPart.Anchored = false
end

-- Main AI loop
while true do
	local target, dist = getNearestPlayer()
	if target then
		-- Follow the player if not too close
		if dist > STOP_RADIUS then
			local targetXZ = Vector3.new(target.Position.X, 0, target.Position.Z)
			moveTo(Vector3.new(targetXZ.X, FIXED_Y, targetXZ.Z))
		else
			-- Stand still if close enough
			task.wait(0.5)
		end
	else
		-- Idle wandering
		local wanderPoint = getRandomWanderPoint()
		moveTo(wanderPoint)
		task.wait(math.random(WANDER_WAIT_MIN, WANDER_WAIT_MAX))
	end
	task.wait(0.1)
end
